{
  "language": "Solidity",
  "sources": {
    "contracts/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface ISwapper {\n\n    enum Status {\n        Pending,\n        Approved,\n        Claimed,\n        Canceled\n    }\n\n    event DealCreated(\n        address proposer1,\n        address executor1,\n        address token1, \n        uint256 amount1, \n        address proposer2,\n        address executor2, \n        address token2, \n        uint256 amount2,\n        uint256 startDate,\n        uint256 vesting,\n        uint256 deadline\n    );\n\n    event DealApproved(uint256 dealId, address executor, address proposer1, address proposer2);\n\n    event DealClaimed(uint256 dealId, address executor, address proposer1, address proposer2);\n\n    event DealCanceled(uint256 dealId, address executor, address proposer1, address proposer2);\n\n    /**\n    * @dev Creates a new Deal after Transfer at address `token1` \n    * of `amount1` tokens from the caller's account to Swapper contract.\n    * \n    * This requires the caller to have approved Swpper contract for `amount1` \n    * to be transfered\n    *\n    * Returns a boolean value indicating whether the operation succeeded\n    * and the id of the Deal created.\n    *\n    * Emits a {DealCreated} event.\n    */\n    function propose(\n        address proposer1,\n        address token1, \n        uint256 amount1,\n        address proposer2, \n        address account2, \n        address token2, \n        uint256 amount2, \n        uint256 vesting,\n        uint256 deadline\n    ) external returns(bool, uint256);\n\n    /**\n    * @dev Update the Deal status to `Approved` after Transfer token of\n    * amount set in the Deal for second account.\n    *\n    * This requires the account2 to have approved Swapper contract for \n    * the amount2 in the Deal at address token2.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {DealApproved} event.\n    */\n    function approve(uint256 id) external returns (bool);\n\n    /**\n    * @dev Send the amount of tokens to the Deal stakeholders. \n    * This requires the vesting period set in the Deal to be over.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {DealClaimed} event.\n    */\n    function claim(uint256 id) external returns (bool);\n\n    /**\n    * @dev Cancel the Deal proposal after the acceptance period is over. \n    * This requires only the proposer to be the function caller and the \n    * deal to be still pending which means not yet accepted by the other \n    * stakeholder.\n    *\n    * Returns a boolean value indicating whether the operation succeeded.\n    *\n    * Emits a {DealCanceled} event.\n    */\n    function cancel(uint256 id) external returns (bool);\n}"
    },
    "contracts/Swapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"./ISwapper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract Swapper is ISwapper {\n    using Counters for Counters.Counter;\n    Counters.Counter private _dealId;\n\n    // TODO: refacto this ugly struct\n    // deal_id => pair of Offer()\n    struct Deal {\n        address proposer1;\n        address proposer2;\n        address account1;\n        address account2;\n        address token1;\n        address token2;\n        uint256 amount1;\n        uint256 amount2;\n        uint256 startDate;\n        uint256 vesting;\n        uint256 deadline;\n        Status status;\n    }\n    mapping(uint256 => Deal) public _deals;\n\n    mapping(address => mapping(address => uint256)) private _balances;\n\n    function propose(\n        address proposer1,\n        address token1, \n        uint256 amount1,\n        address proposer2, \n        address account2, \n        address token2, \n        uint256 amount2, \n        uint256 vesting,\n        uint256 deadline\n    ) external override returns(bool, uint256) {\n       \n        _transfer(msg.sender, token1, amount1);\n        \n        uint256 id = _dealId.current();\n        _deals[id] = Deal({\n            proposer1: proposer1,\n            proposer2: proposer2,\n            account1: msg.sender, \n            account2: account2,\n            token1: token1,\n            token2: token2,\n            amount1: amount1,\n            amount2: amount2,\n            startDate: block.number,\n            vesting: vesting,\n            deadline: deadline,\n            status: Status.Pending\n        });\n        _dealId.increment();\n\n        emit DealCreated(\n            proposer1, \n            msg.sender, \n            token1, \n            amount1, \n            proposer2, \n            account2, \n            token2, \n            amount2, \n            block.number, \n            vesting, \n            deadline\n        );\n\n        return (true, id);\n    }\n\n    function approve(uint256 id) external override returns (bool) {\n        Deal storage deal = _deals[id];\n\n        require(msg.sender == deal.account2, \"Swapper: caller not allowed\");\n\n        _transfer(msg.sender, deal.token2, deal.amount2);\n        \n        deal.status = Status.Approved;\n\n        emit DealApproved(id, msg.sender, deal.proposer1, deal.proposer2);\n\n        return true;\n    }\n\n    function claim(uint256 id) external override returns (bool) {\n        Deal storage deal = _deals[id];\n        \n        require(deal.startDate + deal.vesting <= block.number, \"Swapper: vesting period is not over\");\n\n        IERC20(deal.token1).transfer(deal.account2, deal.amount1);\n        IERC20(deal.token2).transfer(deal.account1, deal.amount2);\n\n        deal.status = Status.Claimed;\n        \n        emit DealClaimed(id, msg.sender, deal.proposer1, deal.proposer2);\n        \n        return true;\n    }\n\n    function cancel(uint256 id) external override returns (bool) {\n        Deal storage deal = _deals[id];\n        require(deal.account1 == msg.sender, \"Swapper: caller is not the deal proposer\");\n        require(deal.status == Status.Pending, \"Swapper: deal is no longer pending\");\n        require(deal.startDate + deal.deadline >= block.number, \"Swapper: acceptance period is not over\");\n        IERC20(deal.token1).transfer(deal.account1, deal.amount1);\n        deal.status = Status.Canceled;\n        \n        emit DealCanceled(id, msg.sender, deal.proposer1, deal.proposer2);\n\n        return true;\n    }\n\n    function _transfer(address account, address token, uint256 amount) private {\n        uint256 allowance = IERC20(token).allowance(account, address(this));\n        require(allowance >= amount, \"Swapper: needs allowance\");\n        \n        bool success = IERC20(token).transferFrom(account, address(this), amount);\n        require(success, \"Swapper: token transfer has failed\");\n\n        _balances[account][token] = amount;\n    }\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}